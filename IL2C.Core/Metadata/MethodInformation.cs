using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

using Mono.Cecil;
using Mono.Cecil.Cil;

namespace IL2C.Metadata
{
    [Flags]
    public enum FriendlyNameTypes
    {
        Less = 0x00,
        FullName = 0x01,
        ArgumentTypes = 0x02,
        ArgumentNames = 0x03,
        Index = 0x08,
        Full = 0x0f,
        Mangled = 0x10,
    }

    public interface IMethodInformation : IMemberInformation
    {
        bool IsPublic { get; }
        bool IsFamily { get; }
        bool IsFamilyOrAssembly { get; }

        bool IsConstructor { get; }
        bool IsStatic { get; }
        bool IsVirtual { get; }
        bool IsAbstract { get; }
        bool IsSealed { get; }
        bool IsNewSlot { get; }
        bool IsReuseSlot { get; }
        bool IsExtern { get; }
        bool HasThis { get; }
        bool HasBody { get; }

        ITypeInformation ReturnType { get; }
        IParameterInformation[] Parameters { get; }
        ILocalVariableInformation[] LocalVariables { get; }
        IMethodInformation[] Overrides { get; }

        ICodeStream CodeStream { get; }
        int OverloadIndex { get; }

        string GetFriendlyName(FriendlyNameTypes type = FriendlyNameTypes.Full);
        IParameterInformation[] GetParameters(ITypeInformation thisType);

        PInvokeInfo PInvokeInfo { get; }

        string CLanguageFunctionName { get; }
        string CLanguageFunctionPrototype { get; }
        string CLanguageFunctionTypePrototype { get; }

        string GetCLanguageDeclarationName(int overloadIndex);
        string GetCLanguageFunctionPrototype(int overloadIndex);
    }

    internal sealed class MethodInformation
        : MemberInformation<MethodReference, MethodDefinition>, IMethodInformation
    {
        private static readonly DebugInformation[] emptyDebug = new DebugInformation[0];
        private static readonly CustomAttribute[] emptyCustomAttribute = new CustomAttribute[0];

        public MethodInformation(MethodReference method, ModuleInformation module)
            : base(method, module)
        {
        }

        public override string MemberTypeName =>
            this.IsConstructor ?
                (this.IsStatic ? "Type initializer" : "Constructor") :
                this.IsStatic ?
                    "Static method" :
                    this.IsAbstract ?
                        this.DeclaringType.IsInterface ?
                            "Interface method" :
                            "Abstract method" :
                        this.IsVirtual ?
                            "Virtual method" :
                            "Method";

        private IParameterInformation CreateThisParameterInformation(ITypeInformation thisType) =>
            new ParameterInformation(
                this,
                0,
                "this__",
                thisType.IsValueType ? thisType.MakeByReference() : thisType,
                emptyCustomAttribute);

        private IParameterInformation ToParameterInformation(ParameterReference parameter) =>
            new ParameterInformation(
                this,
                this.HasThis ? (parameter.Index + 1) : parameter.Index,
                parameter.Name,
                this.MetadataContext.GetOrAddType(parameter.ParameterType),
                parameter.Resolve().CustomAttributes.ToArray());

        public override string MetadataTypeName => "Method";

        public override string FriendlyName =>
            this.GetFriendlyName(FriendlyNameTypes.ArgumentTypes | FriendlyNameTypes.ArgumentNames);

        public override string MangledName =>
            this.GetFriendlyName(FriendlyNameTypes.Index | FriendlyNameTypes.Mangled);

        public bool IsPublic =>
            this.Definition.IsPublic;
        public bool IsFamily =>
            this.Definition.IsFamily;
        public bool IsFamilyOrAssembly =>
            this.Definition.IsFamilyOrAssembly;

        public bool IsConstructor =>
            this.Definition.IsConstructor;
        public bool IsStatic =>
            this.Definition.IsStatic;
        public bool IsVirtual =>
            this.Definition.IsVirtual &&
            // HACK:
            //   1. We can drop newslot virtual if the class is sealed. (ex: the "Invoke" method at derived delegate type generated by the Roslyn.)
            //   2. The method at value type maybe marked virtual, so it made unmarking here.
            !(this.DeclaringType.IsSealed && this.IsNewSlot) &&
            !(this.DeclaringType.IsValueType && !this.IsReuseSlot);
        public bool IsAbstract =>
            this.Definition.IsAbstract;
        public bool IsSealed =>
            this.Definition.IsFinal || this.DeclaringType.IsSealed;
        public bool IsNewSlot =>
            this.Definition.IsNewSlot;
        public bool IsReuseSlot =>
            this.Definition.IsReuseSlot;
        public bool IsExtern =>
            this.Definition.IsPInvokeImpl || this.Definition.IsInternalCall ||
            // HACK: Externed but not marked method (ex: delegate constructor)
            (!this.HasBody && (this.IsConstructor || !this.IsAbstract));
        public bool HasThis =>
            this.Definition.HasThis;
        public bool HasBody => 
            this.Definition.HasBody;

        public ITypeInformation ReturnType =>
            this.MetadataContext.GetOrAddType(this.Member.ReturnType) ?? this.MetadataContext.VoidType;
        public IParameterInformation[] Parameters =>
            (this.Member.HasThis) ?
                new[] { this.CreateThisParameterInformation(this.DeclaringType) }.
                    Concat(this.Member.Parameters.Select(this.ToParameterInformation)).
                    ToArray() :
                this.Member.Parameters.
                    Select(ToParameterInformation).
                    ToArray();
        public ILocalVariableInformation[] LocalVariables =>
            this.Definition.Body.Variables.
                Select(variable => new LocalVariableInformation(
                    this,
                    variable.Index,
                    this.Definition.Body.Method.DebugInformation.TryGetName(variable, out var name) ?       // TODO: every failed?
                        name :
                        string.Format("local{0}__", variable.Index),
                    this.MetadataContext.GetOrAddType(variable.VariableType))).
                ToArray();
        public IMethodInformation[] Overrides =>
            this.Definition.Overrides.
            Select(om => this.MetadataContext.GetOrAddMethod(om)).
            ToArray();

        private static int GetExceptionHandlerTypePriority(ExceptionHandlerType type)
        {
            switch (type)
            {
                case ExceptionHandlerType.Catch:
                case ExceptionHandlerType.Filter:
                case ExceptionHandlerType.Fault: return 0;
                case ExceptionHandlerType.Finally: return 1;
                default:
                    throw new Exception();
            }
        }

        public ICodeStream CodeStream
        {
            get
            {
                // It gathers sequence point informations.
                // It will use writing the line preprocessor directive.
                var paths = new Dictionary<string, string>();
                var spd =
                    (from sp in this.Definition.DebugInformation.SequencePoints
                     where !sp.IsHidden
                     group sp by sp.Offset into g
                     let sps = g.
                        OrderBy(sp => sp.Offset).
                        Select(sp => new DebugInformation(
                            paths.GetOrAdd(sp.Document.Url, sp.Document.Url),
                            sp.StartLine,
                            sp.StartColumn)).
                        ToArray()
                     where sps.Length >= 1
                     select new { g.Key, sps }).
                    ToDictionary(g => g.Key, g => g.sps);

                var exceptionHandlers =
                    this.Definition.Body.ExceptionHandlers.
                    GroupBy(eh => (tryStart: eh.TryStart.Offset, tryEnd: eh.TryEnd.Offset)).
                    OrderBy(g => g.Key.tryStart).
                    ThenByDescending(g => g.Key.tryEnd).
                    Select(g => new ExceptionHandler(
                        g.Key.tryStart, g.Key.tryEnd,
                        // Ordered by handler type: catch --> finally
                        g.OrderBy(eh => GetExceptionHandlerTypePriority(eh.HandlerType)).
                            Select(eh => new ExceptionCatchHandler(
                            (eh.HandlerType == ExceptionHandlerType.Catch) ? ExceptionCatchHandlerTypes.Catch : ExceptionCatchHandlerTypes.Finally,
                            this.MetadataContext.GetOrAddType(eh.CatchType),
                            eh.HandlerStart.Offset,
                            eh.HandlerEnd.Offset)).
                        ToArray())).
                    ToArray();

                var codeStream = new CodeStream(exceptionHandlers);

                object translateOperand(object operand)
                {
                    var inst = operand as Instruction;
                    if (inst != null)
                    {
                        return codeStream[inst.Offset];
                    }

                    var parameter = operand as ParameterReference;
                    if (parameter != null)
                    {
                        return this.Parameters[this.HasThis ? (parameter.Index + 1) : parameter.Index];
                    }

                    var local = operand as VariableReference;
                    if (local != null)
                    {
                        return this.LocalVariables[local.Index];
                    }

                    var typeRef = operand as TypeReference;
                    if (typeRef != null)
                    {
                        return this.MetadataContext.GetOrAddType(typeRef);
                    }

                    var fieldRef = operand as FieldReference;
                    if (fieldRef != null)
                    {
                        return this.MetadataContext.GetOrAddField(fieldRef);
                    }

                    var methodRef = operand as MethodReference;
                    if (methodRef != null)
                    {
                        return this.MetadataContext.GetOrAddMethod(methodRef);
                    }

                    return operand;
                }

                foreach (var inst in this.Definition.Body.Instructions.
                    OrderBy(instruction => instruction.Offset).
                    Select(instruction => new CodeInformation(
                        this,
                        instruction.Offset,
                        instruction.OpCode,
                        instruction.Operand,
                        instruction.GetSize(),
                        spd.TryGetValue(instruction.Offset, out var sps) ? sps : emptyDebug,
                        translateOperand)))
                {
                    codeStream.Add(inst.Offset, inst);
                }
                return codeStream;
            }
        }

        public int OverloadIndex
        {
            get
            {
                var dict = this.DeclaringType.DeclaredMethods.
                    CalculateOverloadMethods();
                var found = dict[this.Member.Name].
                    Select((m, i) => new { m, i }).
                    First(e => this.Equals(e.m));
                return found.i;
            }
        }

        private static bool FullName(FriendlyNameTypes type) =>
            (type & FriendlyNameTypes.FullName) == FriendlyNameTypes.FullName;

        private static bool IncludeNames(FriendlyNameTypes type) =>
            (type & FriendlyNameTypes.ArgumentNames) == FriendlyNameTypes.ArgumentNames;

        private static bool IncludeTypes(FriendlyNameTypes type) =>
            (type & FriendlyNameTypes.ArgumentTypes) == FriendlyNameTypes.ArgumentTypes;

        private static bool IncludeIndex(FriendlyNameTypes type) =>
            (type & FriendlyNameTypes.Index) == FriendlyNameTypes.Index;

        private static bool Mangled(FriendlyNameTypes type) =>
            (type & FriendlyNameTypes.Mangled) == FriendlyNameTypes.Mangled;

        public string GetFriendlyName(FriendlyNameTypes type = FriendlyNameTypes.Full)
        {
            // Apply index number if NOT default method (method have no arguments)
            var index = (IncludeIndex(type) && (this.OverloadIndex >= 1))
                ? string.Format("@{0}", this.OverloadIndex)
                : string.Empty;

            var arguments = (IncludeNames(type) || IncludeTypes(type))
                ? string.Format(
                    "({0})",
                    string.Join(
                        ", ",
                        this.Parameters.Select(parameter =>
                            (IncludeNames(type) && IncludeTypes(type))
                                ? string.Format(
                                    "{0} {1}",
                                    parameter.TargetType.FriendlyName,
                                    parameter.ParameterName)
                                : IncludeTypes(type)
                                    ? parameter.TargetType.FriendlyName
                                    : parameter.ParameterName)))
                : string.Empty;

            var name = string.Format(
                "{0}{1}{2}",
                FullName(type) ? this.Member.GetFriendlyName() : this.Member.Name,
                index,
                arguments);

            return Mangled(type) ? Utilities.GetMangledName(name) : name;
        }

        public IParameterInformation[] GetParameters(ITypeInformation thisType)
        {
            Debug.Assert(this.Member.HasThis);

            return new[] { this.CreateThisParameterInformation(thisType) }.
                Concat(this.Member.Parameters.Select(this.ToParameterInformation)).
                ToArray();
        }

        public PInvokeInfo PInvokeInfo =>
            this.Definition.PInvokeInfo;

        public override bool IsCLanguagePublicScope =>
            this.Definition.IsPublic;
        public override bool IsCLanguageLinkageScope =>
            !this.Definition.IsPublic && !this.Definition.IsPrivate;
        public override bool IsCLanguageFileScope =>
            this.Definition.IsPrivate;

        public string CLanguageFunctionName =>
            this.GetFriendlyName(FriendlyNameTypes.FullName | FriendlyNameTypes.Index | FriendlyNameTypes.Mangled);

        public string CLanguageFunctionPrototype
        {
            get
            {
                var parametersString = string.Join(
                    ", ",
                    this.Parameters.Select(parameter => string.Format(
                        "{0} {1}",
                        parameter.TargetType.CLanguageTypeName,
                        parameter.ParameterName)));

                var returnTypeName =
                    this.ReturnType.CLanguageTypeName;

                return string.Format(
                    "{0} {1}({2})",
                    returnTypeName,
                    this.CLanguageFunctionName,
                    parametersString);
            }
        }

        public string CLanguageFunctionTypePrototype =>
            this.GetCLanguageFunctionPrototype(-1);

        public string GetCLanguageDeclarationName(int overloadIndex)
        {
            return
                (overloadIndex == 0) ? this.Name :
                (overloadIndex == -1) ? string.Empty :
                string.Format("{0}_{1}", this.Name, overloadIndex);
        }

        public string GetCLanguageFunctionPrototype(int overloadIndex)
        {
            // Generate function type prototype if overloadIndex == -1.
            //   [0] : int32_t (*GetHashCode)(void* this__)
            //   [1] : int32_t (*GetHashCode_1)(void* this__)
            //   [2] : int32_t (*GetHashCode_2)(void* this__)
            //   [-1]: int32_t (*)(void*)

            // The first argument (arg0) is switched type name by virtual attribute between strict type and "void*."
            //   non virtual : int32_t (*DoThat)(System_String* this__)
            //   virtual     : int32_t (*DoThat)(void* this__)

            var parametersString = string.Join(
                ", ",
                this.Parameters.Select((parameter, index) => string.Format(
                    "{0}{1}",
                    (this.IsVirtual && (index == 0)) ? "void*" : parameter.TargetType.CLanguageTypeName,
                    (overloadIndex == -1) ? string.Empty : (" " + parameter.ParameterName))));

            var returnTypeName = this.ReturnType.CLanguageTypeName;
            var name = this.GetCLanguageDeclarationName(overloadIndex);

            return string.Format(
                "{0} (*{1})({2})",
                returnTypeName,
                name,
                parametersString);
        }

        protected override MethodDefinition OnResolve(MethodReference member) =>
            member.Resolve();
    }
}
